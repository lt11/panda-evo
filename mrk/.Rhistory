#                 "TY1",
#                 "TY1/TY2_soloLTR",
#                 "TY1_truncated",
#                 "TY2",
#                 "TY3_soloLTR",
#                 "TY4_soloLTR",
#                 "TSU4_soloLTR",
#                 "TY4_truncated",
#                 "TY5",
#                 "TY5_soloLTR",
#                 "LTR_retrotransposon",
#                 "long_terminal_repeat",
#                 "W_region",
#                 "Z1_region",
#                 "Z2_region",
#                 "centromere",
#                 "centromere_DNA_Element_I",
#                 "centromere_DNA_Element_II",
#                 "centromere_DNA_Element_III",
#                 "matrix_attachment_site",
#                 "X_element",
#                 "X_element_partial",
#                 "X_element_combinatorial_repeat",
#                 "X_region",
#                 "Y_prime_element",
#                 "Y_region",
#                 "recombination_enhancer",
#                 "silent_mating_type_cassette_array",
#                 "mating_type_region",
#                 "tRNA",
#                 "pseudogenic_transcript",
#                 "ncRNA",
#                 "ncRNA_gene",
#                 "non_transcribed_region",
#                 "rRNA",
#                 "rRNA_gene",
#                 "snRNA",
#                 "snRNA_gene",
#                 "snoRNA",
#                 "snoRNA_gene",
#                 "intein_encoding_region")
### just in case there's some redundancy
vtClassSrt <- unique(vtClassSrt)
## clmnt ----------------------------------------------------------------------
### script name
myName <- current_filename()
cat("[", myName, "] ",
"Transforming the gff to bed. ",
"\n", sep = "")
### read strain-haplotypes ids from file
pathIds <- list.files(path = file.path(dirBase, "ids"), pattern = "ids-ps.txt",
full.names = T)
vtStrainHaplo <- as.character(fread(file = pathIds, header = F)[[1]])
vtRef <- grep(prefRef, vtStrainHaplo, value = T)
### remove the reference
vtStrainHaplo <- grep(prefRef, vtStrainHaplo, value = T, invert = T)
vtClassSrt <- c("gene",
"pseudogene")
#                 "ncRNA_gene",
#                 "non_transcribed_region",
#                 "rRNA",
#                 "rRNA_gene",
#                 "snRNA",
#                 "snRNA_gene",
#                 "snoRNA",
#                 "snoRNA_gene",
#                 "intein_encoding_region")
### just in case there's some redundancy
vtClassSrt <- unique(vtClassSrt)
### script name
myName <- current_filename()
cat("[", myName, "] ",
"Transforming the gff to bed. ",
"\n", sep = "")
### read strain-haplotypes ids from file
pathIds <- list.files(path = file.path(dirBase, "ids"), pattern = "ids-ps.txt",
full.names = T)
vtStrainHaplo <- as.character(fread(file = pathIds, header = F)[[1]])
vtRef <- grep(prefRef, vtStrainHaplo, value = T)
### remove the reference
vtStrainHaplo <- grep(prefRef, vtStrainHaplo, value = T, invert = T)
vtRef
indR <- vtRef
### read the gff
pathAnnoGff <- list.files(path = dirAnnoGff, pattern = indR,
full.names = T, recursive = T)
dtGff <- fread(file = pathAnnoGff, sep = "\t", header = F, verbose = F)
colnames(dtGff) <- hdGff
### id
strIdPref <- paste0(sub(pattern = "-", replacement = "#", x = indR), "#")
### check start and end coordinates: sometimes start = end and impg breaks
dtGff <- dtGff[S_coord < E_coord]
### filter features
dtGff <- dtGff[Feat_type %in% vtClassSrt, ]
### make the feature id column
strFeatId <- sub("^.*Name=([^;]*).*$", "\\1", dtGff$Attribute_str)
### trim after the first ":", e.g. Name=TY3_soloLTR:chrI:183676-184015:-
strFeatIdTrm <- sub("^([^:]*).*$", "\\1", strFeatId)
### trim trailing redundancy, e.g. _intron in YAL003W_intron
strFeatIdTrm <- sub("^([^_]*).*$", "\\1", strFeatId)
### if strFeatId = dtGff[, Feat_type] set strFeatId = "MN"
indM <- which(dtGff[, Feat_type] == strFeatIdTrm)
indM
### paste class and feature id (and the strand)
strName <- paste0(dtGff[, Feat_type], ":",
strFeatIdTrm, "#", dtGff[, Strand_id])
### transform the gff into a bed file
dtBed <- data.table(chrom = paste0(strIdPref, dtGff[, Chr_id]),
chromStart = dtGff[, S_coord],
chromEnd = dtGff[, E_coord],
name = strName)
### write the bed file
nameOut <- sub(pattern = "-features.gff$", replacement = ".bed",
x = basename(pathAnnoGff))
pathOutBed <- file.path(dirOut, nameOut)
fwrite(file = pathOutBed, x = dtBed, sep = "\t",
quote = F, row.names = F, col.names = F)
indS <- vtStrainHaplo[1]
### read the gff
pathAnnoGff <- list.files(path = dirAnnoGff, pattern = indS,
full.names = T, recursive = T)
dtGff <- fread(file = pathAnnoGff, sep = "\t", header = F, verbose = F)
colnames(dtGff) <- hdGff
### id
strIdPref <- paste0(sub(pattern = "-", replacement = "#", x = indS), "#")
### check start and end coordinates: sometimes start = end and impg breaks
dtGff <- dtGff[S_coord < E_coord]
### filter features
dtGff <- dtGff[Feat_type %in% vtClassSrt, ]
### make the feature id column
strFeatId <- sub("^.*Name=([^;]*).*$", "\\1", dtGff$Attribute_str)
### trim after the first ":", e.g. Name=TY3_soloLTR:chrI:183676-184015:-
strFeatIdTrm <- sub("^([^:]*).*$", "\\1", strFeatId)
### trim "tRNA_" from feature id
strFeatIdTrm <- sub(pattern = "tRNA_", replacement = "", x = strFeatIdTrm)
### indexes of the rows that do not contain
### nuclear gene names with systematic names, e.g. YAL062W
indSys <- grep(pattern = "^Y[A-P][L,R][0-9]{3}[W,C]",
x = strFeatIdTrm, value = F, invert = T)
### if strFeatId = dtGff[, Feat_type] set strFeatId = "MN"
indM <- which(dtGff[, Feat_type] == strFeatIdTrm)
indM
View(dtGff)
View(dtGff[indM, ])
indM
strFeatIdTrm[indM] <- paste0(dtGff[indM, Strain_id], "_",
dtGff[indM, Chr_id], ":",
dtGff[indM, S_coord], "-",
dtGff[indM, E_coord])
View(dtGff[indM, ])
strFeatIdTrm[indM]
options(scipen = 999)
options(stringsAsFactors = F)
rm(list = ls())
library(data.table)
library(this.path)
library(scriptName)
## function(s) ----------------------------------------------------------------
#' Count Non-NA Values in a Vector
#'
#' This function takes a numeric, character, or logical vector and counts
#' the number of non-NA (non-missing) values in it.
#'
#' @param x A vector of any type (numeric, character, or logical)
#'          from which non-NA values will be counted.
#' @return An integer representing the number of non-NA values in `x`.
#' @examples
#' # example usage:
#' CountNoNa(c(1, 2, NA, 4, NA))    # returns 3
#' CountNoNa(c("A", "B", NA, "D"))  # returns 3
#' CountNoNa(c(TRUE, NA, NA, TRUE)) # returns 2
#' @export
CountNoNa <- function(x) {
z <- sum(!is.na(x))
return(z)
}
#' Count Semicolon-Separated Sub-strings in a Vector
#'
#' This function counts the total number of sub-strings
#' in a string vector where
#' elements are made of sub-strings separated by semicolons (`;`).
#' It first removes `NA` values,
#' then splits each remaining string by `;`,
#' and finally sums up the total
#' number of separated elements.
#'
#' @param x A character vector where elements may contain
#'          semicolon-separated values.
#' @return An integer representing the total number of elements after splitting
#'         non-NA values by semicolons.
#' @examples
#' # example usage:
#' CountSemicSep(c("A;B;C", "D;E", NA, "F")) # returns 6 (3+2+1)
#' CountSemicSep(c(NA, "X;Y;Z", "P;Q", ""))  # returns 5 (3+2+0)
#' CountSemicSep(c(NA, NA))                  # returns 0
#' @export
CountSemicSep <- function(x) {
z <- sum(lengths(strsplit(x[!is.na(x)], ";")))
return(z)
}
#' Count Features in a Comma-Separated String
#'
#' This function counts the number of features in a character vector where
#' values are separated by commas (`,`).
#' If a value does not contain any commas,
#' it is assumed to be a single feature.
#' The function correctly handles `NA` values.
#'
#' @param x A character vector where each element may contain
#'          comma-separated features.
#' @return An integer vector of the same length as `x`, where each value
#'         represents the number of features
#'         in the corresponding element of `x`.
#' @examples
#' # example usage:
#' CountAnyFeat(c("A,B,C", "D,E", NA, "F")) # returns c(3, 2, NA, 1)
#' CountAnyFeat(c("X,Y,Z", "P,Q", "R", "")) # returns c(3, 2, 1, 1)
#' CountAnyFeat(c(NA, NA, "A,B"))           # returns c(NA, NA, 2)
#' @export
CountAnyFeat <- function(x) {
z <- sapply(gregexpr(",", x),
function(y) ifelse(y[1] == -1, 1L, length(y) + 1L))
return(z)
}
#' Count Systematic Gene Features in a Character Vector
#'
#' This function counts the number of occurrences of systematic gene features
#' in a character vector based on a predefined regular expression pattern.
#' The pattern follows the format: `Y[A-P][L,R][0-9]{3}[W,C]`,
#' which is commonly used for systematic yeast gene names.
#'
#' @param x A character vector where each element
#'          may contain systematic gene names.
#' @return An integer vector of the same length as `x`,
#'         where each value represents
#'         the number of systematic gene matches
#'         in the corresponding element of `x`.
#' @examples
#' # example usage:
#' CountSysFeat(c("YAL001W,YBR102C", "YDL113C,YGR098W", NA, "YPR202W"))
#' # returns c(2, 2, NA, 1)
#'
#' CountSysFeat(c("YAL003W", "YCR008W,YHR209C", "NotAGene", "Blinda"))
#' # returns c(1, 2, 0, 0)
#'
#' CountSysFeat(c(NA, NA, "YML075C,YPL197W,YJL112W"))
#' # returns c(NA, NA, 3)
#' @export
CountSysFeat <- function(x) {
### the pattern for systematic yeast gene names
ptnSys <- "Y[A-P][L,R][0-9]{3}[W,C]"
### apply the regular expression and count occurrences
y <- sapply(gregexpr(ptnSys, x, perl = T), function(x) sum(x > 0))
return(y)
}
#' Count Random Identifier Gene Features in a Character Vector
#'
#' This function counts the number of occurrences of genes with a random id
#' in a character vector based on a predefined regular expression pattern.
#' The pattern follows the format: `"_G[0-9]{7}"`, which identifies gene ids
#' starting with the stain name, followed by `_G`,
#' followed by exactly seven digits.
#'
#' @param x A character vector where each element
#'          may contain random ID gene names.
#' @return An integer vector of the same length as `x`,
#'         where each value represents
#'         the number of random ID gene matches
#'         in the corresponding element of `x`.
#' @examples
#' # example usage:
#' CountRidFeat(c("ABA_G0053280,CMF_HP1_G0054150", "AAB_G7654321"))
#' # returns c(2, 1)
#'
#' CountRidFeat(c("DBVPG6765_G0027560,YFL051C,YJL216C", "", "NoMatch"))
#' # returns c(1, 0, 0)
#'
#' CountRidFeat(c(NA, NA, "AAB_G5555555,AIL_G6666666"))
#' # returns c(NA, NA, 2)
#' @export
CountRidFeat <- function(x) {
### the pattern for random ID genes
ptnRid <- "_G[0-9]{7}"
### apply the regular expression and count occurrences
y <- sapply(gregexpr(ptnRid, x, perl = T), function(x) sum(x > 0))
return(y)
}
#' Prepend Column Names to Substrings in Selected Columns of a data.table
#'
#' This function modifies a `data.table` by prepending each value
#' in the specified columns
#' with the corresponding column name followed by `#`.
#' Substrings within a column are assumed
#' to be separated by semicolons (`;`). `NA` values remain unchanged.
#'
#' @param x A `data.table` containing the dataset to be modified.
#' @param y A numeric vector of column indices specifying
#'          which columns should be modified.
#'
#' @return The input `data.table` is modified in-place,
#' with the selected columns updated
#' to have their column names prefixed to each substring.
#'
#' @examples
#' library(data.table)
#'
#' # create example data.table
#' dt <- data.table(
#'   ID = 1:3,
#'   SGD#0 = c("chrIV:30-32", "chrXIV:386-541;chrXIV:260-415", NA),
#'   AAB#1 = c("", "chrV:35-80", "chrXII:99-111")
#' )
#'
#' # define columns to modify
#' # (assuming SGD#0 is in column 2 and AAB#1 in column 3)
#' indHapCols <- c(2, 3)
#'
#' # apply the function
#' AddColPref(dt, indHapCols)
#'
#' # expected output:
#' #     ID   SGD#0                                        AAB#1
#' # 1:  1    SGD#0#chrIV:30-32                            ""  (unchanged)
#' # 2:  2    SGD#0#chrXIV:386-541;SGD#0chrXIV:260-415     AAB#1#chrV:35-80
#' # 3:  3    NA (unchanged)                               AAB#1#chrXII:99-111
#'
#' @export
AddColPref <- function(x, y) {
x[, (y) := lapply(y, function(indC) {
col_name <- names(x)[indC]
ifelse(!is.na(x[[indC]]),
gsub("([^;]+)", paste0(col_name, "#\\1"), x[[indC]], perl = T),
x[[indC]])})]
return(x)
}
#' Replace NA Values with Empty Strings in a data.table
#'
#' This function modifies a data.table replacing all NA values
#' with empty strings ("").
#' You can choose whether to apply this only to character
#' columns or to all columns
#' (which will coerce all types to character).
#'
#' @param x A `data.table` object to modify in-place.
#' @param y Logical. If `TRUE`, replaces NA in all columns
#'          (and coerces to character).
#'          If `FALSE` (default), replaces only NA values
#'          in character columns.
#'
#' @return The modified `data.table` with NA values replaced by "".
#' @examples
#' library(data.table)
#' x <- data.table(A = c("apple", NA), B = c(NA, "orange"), C = c(1, NA))
#' ReplaceNAtoEmpty(x)         # only character columns
#' ReplaceNAtoEmpty(x, TRUE)   # all columns, coerced to character
ReplaceNAtoEmpty <- function(x, y = F) {
if (!data.table::is.data.table(x)) {
### stop prints "Error: " by default
stop("input must be a data.table.")
}
colsToMod <- if (y) names(x) else names(x)[sapply(x, is.character)]
x[, (colsToMod) := lapply(.SD, function(x) {
x[is.na(x)] <- ""
x
}), .SDcols = colsToMod]
return(x)
}
#' Replace Empty Strings with NA Values in a data.table
#'
#' This function modifies a data.table by replacing all empty strings ("")
#' with NA values. You can choose whether to apply this only to character
#' columns or to all columns (which will coerce all types to character).
#'
#' @param x A `data.table` object to modify in-place.
#' @param y Logical. If `TRUE`, replaces "" in all columns
#'          (and coerces to character).
#'          If `FALSE` (default), replaces only "" values
#'          in character columns.
#'
#' @return The modified `data.table` with "" values replaced by NA.
#' @examples
#' library(data.table)
#' x <- data.table(A = c("apple", ""), B = c("", "orange"), C = c("1", ""))
#' ReplaceEmptyToNA(x)         # only character columns
#' ReplaceEmptyToNA(x, TRUE)   # all columns, coerced to character
ReplaceEmptyToNA <- function(x, y = F) {
if (!data.table::is.data.table(x)) {
stop("input must be a data.table.")
}
colsToMod <- if (y) names(x) else names(x)[sapply(x, is.character)]
x[, (colsToMod) := lapply(.SD, function(col) {
col[col == ""] <- NA
col
}), .SDcols = colsToMod]
return(x)
}
#' Filter intervals in a semicolon-separated genomic string based on a list
#' of valid ("kept") intervals.
#'
#' @param cell A character string of the form "chr:start-end;chr:start-end;..."
#'             or NA.
#' @param regs A character vector of intervals to retain, in the
#'             same "chr:start-end" format.
#'
#' @return A semicolon-separated string of intervals found in both the cell
#'         and the kept list, or NA if none match.
#' @examples
#' dtRegions <- data.table(
#' "Class_id" = c("gene", "gene", "gene", "gene", "gene"),
#' "Features_id" = c("anello", "del", "conte", "antani", "sblinda"),
#' "SGDref#0" = c(
#'   "chrVII:9161-9695",
#'   "chrVII:9518-9751",
#'   NA,
#'   "chrXIV:1375-2528;chrXIV:36539-36694;chrIV_chrII:36539-37694",
#'   "chrX:1000-1010;chrX:1200-1800"),
#' "BUCIO#1" = c(
#'   "chrV:9161-9295",
#'   NA,
#'   NA,
#'   NA,
#'   "chrX:1000-2010;chrX:1200-1800"),
#' "DECULO#2" = c(
#'   "chrV:9161-9895",
#'   NA,
#'   NA,
#'   NA,
#'   NA)
#' )
FilterCellByKeptIntervals <- function(cell, reg) {
if (is.na(cell)) return(NA_character_)
allParts <- unlist(strsplit(cell, ";", fixed = T))
intvKept <- allParts[allParts %in% reg]
if (length(intvKept) == 0) return(NA_character_)
paste(intvKept, collapse = ";")
}
### reference genome
idRefHap <- "SGDref-0"
### pattern of systematic genes
ptnSys <- "Y[A-P][L,R][0-9]{3}[W,C]"
### pattern of random id genes
ptnRid <- "_G[0-9]{7}"
### the type of sub-blocks to process
strSblock <- "gene"
### the type of sub-blocks to process
strSblock <- "CDS"
### fixed settings
dirBase <- dirname(this.dir())
dirBase
### output
dirOut <- file.path(dirBase, "sts", strSblock)
unlink(dirOut, recursive = T)
dir.create(dirOut, recursive = T)
pathPanGenesHaplo <- file.path(dirOut, "sts-by-haplos.txt")
pathNorefPriv <- file.path(dirOut, "n-rid-private.txt")
pathCountSblocsRegs <- file.path(dirOut, "n-sblocks-regs.txt")
pathPanGenesGenomes <- file.path(dirOut, "sts-by-genomes.txt")
### script name
myName <- current_filename()
cat("[", myName, "] ",
"Making the statistics. ",
"\n", sep = "")
### load SGDref features
pathBedRef <- file.path(dirBase, "anno", "bed", paste0(idRefHap, ".bed"))
dtBedRef <- fread(file = pathBedRef, sep = "\t", header = F)
names(dtBedRef) <- c("Strain_hap_chr", "S_coord",
"E_coord", "Class_feat_strand")
dtBedRefGns <- dtBedRef[grep("^gene", Class_feat_strand)]
dtBedRefGns <- dtBedRef[grep(strSblock, Class_feat_strand)]
View(dtBedRef)
### load the pangenome (dtPanFeats)
pathInPan <- file.path(dirBase, "png", "pan-features.RData")
load(pathInPan)
### we need the first and last haplotype columns to correctly subset
### the data-table when we calculate the statistics
nHaplos <- ncol(dtPanFeats) - 2
indHapCols <- 3:ncol(dtPanFeats)
indHapCols
dtPanFeatsRaw <- dtPanFeats[Class_id == strSblock]
### columns with genomic intervals
intervalCols <- setdiff(names(dtPanFeatsRaw), c("Class_id", "Features_id"))
### process each row independently
dtPanFeatsGns <- dtPanFeatsRaw[, {
### extract all intervals in one row across all genomic columns
allIntervals <- unlist(tstrsplit(unlist(.SD), ";", fixed = T))
allIntervals <- allIntervals[!is.na(allIntervals)
& grepl(":", allIntervals)]
if (length(allIntervals) == 0) {
### if there are no valid intervals
outCols <- lapply(.SD, function(x) NA_character_)
} else {
### calculate interval lengths
intervalCoords <- tstrsplit(gsub(".*:", "", allIntervals), "-", fixed = T)
intervalStarts <- as.numeric(intervalCoords[[1]])
intervalEnds <- as.numeric(intervalCoords[[2]])
intervalLengths <- intervalEnds - intervalStarts
### compute median
M <- median(intervalLengths, na.rm = T)
### identify good intervals (length ≥ 0.5 * M)
indBon <- which(intervalLengths >= 0.5 * M)
bonIntervals <- allIntervals[indBon]
### rebuild each genomic column
outCols <- lapply(.SD, FilterCellByKeptIntervals,
reg = bonIntervals)
}
### return Class_id and Features_id along with filtered columns
c(list(Class_id = Class_id, Features_id = Features_id), outCols)
}, by = seq(1:nrow(dtPanFeatsRaw)), .SDcols = intervalCols]
View(dtPanFeatsGns)
View(dtPanFeatsGns)
View(dtPanFeatsGns)
View(dtPanFeats)
